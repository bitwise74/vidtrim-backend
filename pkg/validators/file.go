package validators

import (
	"bitwise74/video-api/internal/model"
	"errors"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strconv"
	"strings"

	"gorm.io/gorm"
)

var (
	ErrFileTooLarge        = errors.New("file too large")
	ErrFileNameTooLong     = errors.New("file name is too long")
	ErrFileTypeUnsupported = errors.New("unsupported file type")
	ErrNoFile              = errors.New("no file provided")
	ErrNoSpace             = errors.New("not enough space")
	ErrEmptyFile           = errors.New("empty file")
)

type partialUserData struct {
	UsedStorage int64
	MaxStorage  int64
}

const maxFileNameSize = 245 // Takes into account the thumbnail_ prefix

func FileValidator(fh *multipart.FileHeader, db *gorm.DB, userID string) (int, multipart.File, error) {
	if fh == nil {
		return http.StatusBadRequest, nil, ErrNoFile
	}

	maxUploadSize, _ := strconv.ParseInt(os.Getenv("UPLOAD_MAX_SIZE"), 10, 64)

	// No, this wasn't generated by gpt. Yes, I need these comments to not forget
	// anything. Yes, I'm forgetful.

	allowedMimeTypes := strings.Split(os.Getenv("UPLOAD_ALLOWED_TYPES"), ",")

	// Check mime type from header
	ct := fh.Header.Get("Content-Type")
	if ct != "" && !slices.Contains(allowedMimeTypes, ct) {
		return http.StatusBadRequest, nil, ErrFileTypeUnsupported
	}

	// Check for empty file from header
	if fh.Size == 0 {
		return http.StatusBadRequest, nil, ErrEmptyFile
	}

	// Check file size from header
	if fh.Size > maxUploadSize {
		return http.StatusRequestEntityTooLarge, nil, ErrFileTooLarge
	}

	// Check for very long file names
	if len(fh.Filename) > maxFileNameSize {
		return http.StatusBadRequest, nil, ErrFileNameTooLong
	}

	// More secure checks now
	f, err := fh.Open()
	if err != nil {
		return http.StatusInternalServerError, nil, err
	}

	// Check for size
	limited := io.LimitReader(f, maxUploadSize)
	n, err := io.Copy(io.Discard, limited)
	if err != nil {
		return http.StatusInternalServerError, nil, err
	}

	if n > maxUploadSize {
		return http.StatusRequestEntityTooLarge, nil, ErrFileTooLarge
	}

	if db != nil {
		var data partialUserData

		err := db.
			Model(model.Stats{}).
			Where("user_id = ? ", userID).
			Select("used_storage", "max_storage").
			First(&data).
			Error
		if err != nil {
			return http.StatusInternalServerError, nil, err
		}

		if data.UsedStorage+fh.Size > data.MaxStorage {
			return http.StatusConflict, nil, ErrNoSpace
		}
	}

	fh.Filename = sanitizeFileName(fh.Filename)
	f.Seek(0, 0)

	return 0, f, nil
}

func sanitizeFileName(n string) string {
	n = filepath.Base(n)
	n = strings.TrimSpace(n)

	re := regexp.MustCompile(`[^a-zA-Z0-9._-]+`)
	n = re.ReplaceAllString(n, "_")

	if n == "" || n == "." || n == ".." {
		n = "file"
	}

	if len(n) > maxFileNameSize {
		n = n[:maxFileNameSize]
	}

	return n
}
